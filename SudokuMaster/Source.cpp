/*
Kody Mitchell
4/14/22
Final Project
Sudoku Master - A program dealing with all things Sudoku!
*/

/*

    The Magic of the AI is contained within the Algorithm X method of SudokuMaster 
    as well as the files for DoubleLinkedNodeMatrix and DoubleLinkedNode

*/

using namespace std;

#include <SFML/Graphics.hpp>
#include <vector>
#include <memory>
#include <string>
#include <fstream>
#include <thread>
#include <iostream>
#include "Button.h"
#include "SudokuNumberButton.h"
#include "ColorHelper.h"
#include "SudokuMaster.h"
#include "InvalidPuzzleException.h"

void leaveStage(short oldStage, vector<shared_ptr<Button>> stageButtons[]);

void enterStage(short newStage, vector<shared_ptr<Button>> stageButtons[]);

void changeStage(short newStage, short oldStage, vector<shared_ptr<Button>> stageButtons[]);

int main()
{
    //Seed the random number generator
    srand(time(0));

    //LOADING PROGRAM
    cout << "Loading...";

    sf::RenderWindow window(sf::VideoMode(1024, 760), "Sudoku Master");

    //Load general info for the program
    
    //Menu - 0, Difficulty - 1, Play - 2, Congrats - 3, Solve - 4, Solved - 5
    int programStage = 0;
    //The puzzle difficulty, Easy - 1, Medium - 2, Hard - 3
    int difficulty = 0;
    bool generatingPuzzle = false;

    sf::Font font;
    font.loadFromFile("C:\\Windows\\Fonts\\AGENCYR.TTF");

    //Holds a reference to every object that is listening for mouse events. (Note: bad phrasing, technically it's a pointer not a reference)
    vector<shared_ptr<MouseListener>> mouseListeners;

    //There are 6 program stages, we will create some vectors to store the various buttons and things unique for each stage
    vector<shared_ptr<sf::Text>> stageTexts[6];
    vector<shared_ptr<Button>> stageButtons[6];

    //Load texts and buttons for various stages
    //Load Menu
    stageTexts[0].push_back(make_shared<sf::Text>("Welcome to the Sudoku Master!\nPress Play to solve a Sudoku puzzle generated by this program!\nPress Solve to input a puzzle and have the program solve it!\n\tThis can be done manually or by putting a 'solve.txt' file in the program directory.", font, 30));

    stageButtons[0].push_back(make_shared<Button>(font, 28, "Play", ColorHelper::Green, sf::Color::White, 50, 300, 80, 40,
        [&]() {
            changeStage(1, 0, stageButtons);
            programStage = 1;
        }));
    mouseListeners.push_back(stageButtons[0].back());

    stageButtons[0].push_back(make_shared<Button>(font, 28, "Solve", ColorHelper::LightBlue, sf::Color::White, 50, 380, 80, 40,
        [&]() {
            changeStage(4, 0, stageButtons);
            programStage = 4;
        }));
    mouseListeners.push_back(stageButtons[0].back());


    //Load Number Draw Buttons 1-9 and Erase (used in stages 2 and 4)
    shared_ptr<Button> numberColumn[10];
    int y = 150;
    for (int i = 0; i < 9; i++) {
        //Create number buttons that stop listening when they are clicked, and tell all other number buttons to start listening
        numberColumn[i] = make_shared<Button>(font, 22, to_string(i + 1), ColorHelper::AlmostBlack, sf::Color::White, 10, y, 40, 40,
            [&, i]() {
                for (int j = 0; j < 10; j++) {
                    if (j != i) {
                        numberColumn[j]->setListenerEnabled(true);
                        numberColumn[j]->setBackgroundColor(ColorHelper::AlmostBlack);
                    }
                    else {
                        numberColumn[j]->setListenerEnabled(false);
                        numberColumn[j]->setBackgroundColor(ColorHelper::Gray);
                    }
                }
            });
        y += 50;
    }
    //Same thing, but it erases instead of placing numbers
    numberColumn[9] = make_shared<Button>(font, 22, "Erase", ColorHelper::AlmostBlack, sf::Color::White, 10, y, 50, 40,
        [&]() {
            for (int j = 0; j < 10; j++) {
                if (j != 9) {
                    numberColumn[j]->setListenerEnabled(true);
                    numberColumn[j]->setBackgroundColor(ColorHelper::AlmostBlack);
                }
                else {
                    numberColumn[j]->setListenerEnabled(false);
                    numberColumn[j]->setBackgroundColor(ColorHelper::Gray);
                }
            }
        });

    //Add these buttons to stages 2 and 4 and the mouse listeners
    for (int i = 0; i < 10; i++) {
        stageButtons[2].push_back(numberColumn[i]);
        stageButtons[4].push_back(numberColumn[i]);
        mouseListeners.push_back(numberColumn[i]);
    }


    //Load the mark and note buttons for stage 2
    shared_ptr<Button> markNoteButtons[2];
    int x = 382;
    markNoteButtons[0] = make_shared<Button>(font, 22, "Mark", ColorHelper::Gray, sf::Color::White, x, 10, 50, 40,
        [&]() {
            markNoteButtons[0]->setListenerEnabled(false);
            markNoteButtons[0]->setBackgroundColor(ColorHelper::Gray);

            markNoteButtons[1]->setListenerEnabled(true);
            markNoteButtons[1]->setBackgroundColor(ColorHelper::AlmostBlack);
        });
    x += 70;
    markNoteButtons[0]->bindSetupFunction([](Button* b) {b->setListenerEnabled(false); });
    stageButtons[2].push_back(markNoteButtons[0]);
    mouseListeners.push_back(markNoteButtons[0]);

    markNoteButtons[1] = make_shared<Button>(font, 22, "Note", ColorHelper::AlmostBlack, sf::Color::White, x, 10, 50, 40,
        [&]() {
            markNoteButtons[1]->setListenerEnabled(false);
            markNoteButtons[1]->setBackgroundColor(ColorHelper::Gray);

            markNoteButtons[0]->setListenerEnabled(true);
            markNoteButtons[0]->setBackgroundColor(ColorHelper::AlmostBlack);
        });
    x += 70;
    stageButtons[2].push_back(markNoteButtons[1]);
    mouseListeners.push_back(markNoteButtons[1]);


    //Load the Sudoku Master. The brains of the operation
    SudokuMaster master(font, 272, 140,
        //A function that returns the number that is currently selected
        [&]() -> int {
            for (int i = 0; i < 10; i++) {
                if (!numberColumn[i]->getListenerEnabled()) {
                    return i + 1;
                }
            }
            //If no number has been selected, it autoselects 'Erase'
            return 10;
        },

        //A function that returns if we are marking true numbers or just making notes
        [&]() -> bool {
            return !markNoteButtons[0]->getListenerEnabled();
        },
            
        //A function called when the puzzle has been solved
        [&]() {
            changeStage(programStage + 1, programStage, stageButtons);
            programStage += 1;
        });
    //register Sudoku master and its buttons with all relevant stages and to the mouse listener
    for (int i = 2; i < 6; i++) {
        master.registerContainer(stageButtons[i]);
    }
    master.registerContainer(mouseListeners);


    //Loading Difficulty screen
    stageTexts[1].push_back(make_shared<sf::Text>("Choose your difficulty", font, 30));

    //Text to display while the puzzle is generating
    sf::Text generatingText("Generating...", font, 30);
    sf::Rect<float> textBox = generatingText.getLocalBounds();
    //Center text
    generatingText.setOrigin(textBox.width / 2.f, 0);
    generatingText.setPosition(512, 10);

    //Set this to true when we are between stages
    bool inbetweenStages = false;
    
    //This is a mini function to be called by all difficulty buttons (and later the play again button) to launch a couple threads to animate the generation of the puzzle
    auto transitionToPuzzle = [&]() {
        leaveStage(programStage, stageButtons);
        generatingPuzzle = true;
        inbetweenStages = true;
        programStage = 2;
        master.activateButtons();
        //A thread to generate the puzzle
        thread sudokuGenerator([&]() { srand(time(0)); master.createSudokuPuzzle(difficulty); });
        //A thread to wait for the generation and then do some stuff after
        thread waitForNextStage([&]() {
            sudokuGenerator.join();
            generatingPuzzle = false;
            inbetweenStages = false;
            enterStage(2, stageButtons);
        });
        waitForNextStage.join();
    };

    stageButtons[1].push_back(make_shared<Button>(font, 28, "Easy", ColorHelper::AlmostBlack, ColorHelper::Green, 50, 100, 80, 40,
        [&]() {
            difficulty = 1;
            //Detach the thread so it continues running when it goes out of scope in a second.
            thread(transitionToPuzzle).detach();
        }));
    mouseListeners.push_back(stageButtons[1].back());

    stageButtons[1].push_back(make_shared<Button>(font, 28, "Medium", ColorHelper::AlmostBlack, ColorHelper::Yellow, 50, 180, 80, 40,
        [&]() {
            difficulty = 2;
            //Detach the thread so it continues running when it goes out of scope in a second.
            thread(transitionToPuzzle).detach();
        }));
    mouseListeners.push_back(stageButtons[1].back());

    stageButtons[1].push_back(make_shared<Button>(font, 28, "Hard", ColorHelper::AlmostBlack, ColorHelper::Red, 50, 260, 80, 40,
        [&]() {
            difficulty = 3;
            //Detach the thread so it continues running when it goes out of scope in a second.
            thread(transitionToPuzzle).detach();
        }));
    mouseListeners.push_back(stageButtons[1].back());

    stageButtons[1].push_back(make_shared<Button>(font, 28, "Continue", ColorHelper::LightBlue, sf::Color::White, 50, 340, 80, 40,
        [&]() {
            //Load the puzzle and save the difficulty
            difficulty = master.loadPuzzle();
            changeStage(2, 1, stageButtons);
            programStage = 2;
        }));
    stageButtons[1].back()->bindSetupFunction([](Button* b) {
        ifstream file;
        file.open("puzzle.txt");
        //If the file does not exist, do not draw this button
        if (!file) {
            b->setToDraw(false);
            b->setListenerEnabled(false);
        }
        file.close();
    });
    mouseListeners.push_back(stageButtons[1].back());

    
    //Continue Stage 2 buttons
    stageButtons[2].push_back(make_shared<Button>(font, 22, "Check", ColorHelper::LightBlue, sf::Color::White, x, 10, 50, 40,
        [&]() {
            //Check the user's puzzle for errors
            master.checkPuzzle();
        }));
    x += 70;
    mouseListeners.push_back(stageButtons[2].back());

    stageButtons[2].push_back(make_shared<Button>(font, 22, "Hint", ColorHelper::Green, sf::Color::White, x, 10, 50, 40,
        [&]() {
            //Give a hint to the player
            master.giveHint();
        }));
    mouseListeners.push_back(stageButtons[2].back());


    //Loading Stage 3
    stageTexts[3].push_back(make_shared<sf::Text>("Congratulations! You solved the puzzle!", font, 30));
    shared_ptr<sf::Text> lastText = stageTexts[3].back();
    textBox = lastText->getLocalBounds();
    //Center text
    lastText->setOrigin(textBox.width / 2.f, 0);
    lastText->setPosition(512, 10);

    y = 100;
    stageButtons[3].push_back(make_shared<Button>(font, 28, "Play Again", ColorHelper::AlmostBlack, sf::Color::White, 90, y, 100, 40,
        [&]() {
            master.wipeData();
            thread(transitionToPuzzle).detach();
        }));
    y += 80;
    mouseListeners.push_back(stageButtons[3].back());

    stageButtons[3].push_back(make_shared<Button>(font, 28, "Change Difficulty", ColorHelper::AlmostBlack, sf::Color::Yellow, 60, y, 170, 40,
        [&]() {
            master.wipeData();
            changeStage(1, 3, stageButtons);
            programStage = 1;
        }));
    y += 80;
    mouseListeners.push_back(stageButtons[3].back());

    stageButtons[3].push_back(make_shared<Button>(font, 28, "Menu", ColorHelper::LightBlue, sf::Color::White, 105, y, 80, 40,
        [&]() {
            master.wipeData();
            changeStage(0, 3, stageButtons);
            programStage = 0;
        }));
    y += 80;
    mouseListeners.push_back(stageButtons[3].back());


    //Loading stage 4
    stageTexts[4].push_back(make_shared<sf::Text>("Input your puzzle manually here, or create 'solve.txt' in the program directory\nand paste your puzzle in there with zeroes instead of spaces.", font, 30));

    sf::Text loadFailText("Solve.txt not found", font, 30);
    loadFailText.setFillColor(ColorHelper::Red);
    textBox = loadFailText.getLocalBounds();
    //Center text
    loadFailText.setOrigin(textBox.width / 2.f, 0);
    loadFailText.setPosition(512, 720);

    //Set to true when the loading process fails for whatever reason
    bool loadPuzzleFailed = false;

    stageButtons[4].push_back(make_shared<Button>(font, 28, "Load from file", ColorHelper::AlmostBlack, ColorHelper::LightBlue, 25, 700, 130, 40,
        [&]() {
            //Attempt to load the puzzle from "solve.txt"
            ifstream puzzleStream("solve.txt");

            if (!puzzleStream) {
                loadPuzzleFailed = true;
                loadFailText.setString("'solve.txt' not found");
                textBox = loadFailText.getLocalBounds();
                //Center text
                loadFailText.setOrigin(textBox.width / 2.f, 0);
                loadFailText.setPosition(512, 720);
            }
            else {
                try {
                    //Try to put the contents of the file into the user board
                    master.fileToSolve(puzzleStream);
                    loadPuzzleFailed = false;
                }
                catch (InvalidPuzzleException e) {
                    //Puzzle has invalid setup (not there aren't no solutions, just that the formatting is invalid)
                    loadPuzzleFailed = true;
                    loadFailText.setString("Formatting invalid: Expected 9x9 of numbers 0-9. See example.txt for details.");
                    textBox = loadFailText.getLocalBounds();
                    //Center text
                    loadFailText.setOrigin(textBox.width / 2.f, 0);
                    loadFailText.setPosition(532, 720);

                    //Output example file
                    ofstream fileWriter("example.txt");
                    fileWriter << "Like this:\n123456789\n456789123\n000123000\n001002096...\nAnd so on.";
                    fileWriter.close();
                }
            }

            puzzleStream.close();
        }));
    mouseListeners.push_back(stageButtons[4].back());

    //A function to be called in a separate thread when the Done button is pressed (see below)
    auto solvePuzzleFunction = [&]() {
        leaveStage(programStage, stageButtons);
        inbetweenStages = true;
        programStage = 5;
        master.activateButtons();
        //A thread to solve the puzzle
        thread sudokuSolver([&]() { master.solvePuzzle(); });
        //A thread to wait for the generation and then do some stuff after
        thread waitForNextStage([&]() {
            sudokuSolver.join();
            enterStage(5, stageButtons);
            inbetweenStages = false;
        });
        //Join the thread so that this function doesn't finish execution before the threads and put the threads out of scope
        waitForNextStage.join();
    };

    stageButtons[4].push_back(make_shared<Button>(font, 28, "Done", ColorHelper::Green, sf::Color::White, 940, 700, 50, 40,
        [&]() {
            //Attempt to solve the puzzle
            loadPuzzleFailed = false;
            //Detach the thread so it continues running when it goes out of scope in a second.
            thread(solvePuzzleFunction).detach();
        }));
    mouseListeners.push_back(stageButtons[4].back());

    //Load stage 5
    stageTexts[5].push_back(make_shared<sf::Text>("Congrats Text", font, 30));
    shared_ptr<sf::Text> congratsText = stageTexts[5].back();
    textBox = congratsText->getLocalBounds();
    //Center text
    congratsText->setOrigin(textBox.width / 2.f, 0);
    congratsText->setPosition(512, 10);

    stageTexts[5].push_back(make_shared<sf::Text>("Solution Count Text", font, 30));
    shared_ptr<sf::Text> solutionCountText = stageTexts[5].back();
    textBox = solutionCountText->getLocalBounds();
    //Center text
    solutionCountText->setOrigin(textBox.width / 2.f, 0);
    solutionCountText->setPosition(512, 720);

    stageButtons[5].push_back(make_shared<Button>(font, 28, "Next", ColorHelper::AlmostBlack, ColorHelper::LightBlue, 800, 710, 50, 40,
        [&]() {
            master.rotateSolution(true);
            solutionCountText->setString("Viewing solution " + to_string(master.getSolutionIndex() + 1) + " of " + to_string(master.solutionsFound()));
            sf::Rect<float> textBounds = solutionCountText->getLocalBounds();
            //Center text
            solutionCountText->setOrigin(textBounds.width / 2.f, 0);
            solutionCountText->setPosition(512, 720);
        }));
    shared_ptr<Button> nextSolutionButton = stageButtons[5].back();
    mouseListeners.push_back(nextSolutionButton);

    stageButtons[5].push_back(make_shared<Button>(font, 28, "Previous", ColorHelper::AlmostBlack, ColorHelper::Orange, 135, 710, 80, 40,
        [&]() {
            master.rotateSolution(false);
            solutionCountText->setString("Viewing solution " + to_string(master.getSolutionIndex() + 1) + " of " + to_string(master.solutionsFound()));
            sf::Rect<float> textBounds = solutionCountText->getLocalBounds();
            //Center text
            solutionCountText->setOrigin(textBounds.width / 2.f, 0);
            solutionCountText->setPosition(512, 720);
        }));
    shared_ptr<Button> previousSolutionButton = stageButtons[5].back();
    mouseListeners.push_back(previousSolutionButton);

    stageButtons[5].push_back(make_shared<Button>(font, 28, "Menu", ColorHelper::Green, sf::Color::White, 900, 50, 50, 40,
        [&]() {
            master.wipeData();
            changeStage(0, 5, stageButtons);
            programStage = 0;
        }));
    stageButtons[5].back()->bindSetupFunction([&](Button* b) {
            //Change texts for this stage depending on the amount of solutions
            if (master.solutionsFound() > 1) {
                solutionCountText->setString("Viewing solution " + to_string(master.getSolutionIndex() + 1) + " of " + to_string(master.solutionsFound()));
                sf::Rect<float> textBounds = solutionCountText->getLocalBounds();
                //Center text
                solutionCountText->setOrigin(textBounds.width / 2.f, 0);
                solutionCountText->setPosition(512, 720);

                congratsText->setString("Success! Puzzle solved!");
                textBounds = congratsText->getLocalBounds();
                //Center text
                congratsText->setOrigin(textBounds.width / 2.f, 0);
                congratsText->setPosition(512, 10);
            }
            else {
                if (master.solutionsFound() == 1) {
                    solutionCountText->setString("There is one solution");
                    sf::Rect<float> textBounds = solutionCountText->getLocalBounds();
                    //Center text
                    solutionCountText->setOrigin(textBounds.width / 2.f, 0);
                    solutionCountText->setPosition(512, 720);

                    congratsText->setString("Success! Puzzle solved!");
                    textBounds = congratsText->getLocalBounds();
                    //Center text
                    congratsText->setOrigin(textBounds.width / 2.f, 0);
                    congratsText->setPosition(512, 10);
                }
                else {
                    solutionCountText->setString("No solutions found!");
                    sf::Rect<float> textBounds = solutionCountText->getLocalBounds();
                    //Center text
                    solutionCountText->setOrigin(textBounds.width / 2.f, 0);
                    solutionCountText->setPosition(512, 720);

                    congratsText->setString("Sorry! The puzzle you input has no solution.");
                    textBounds = congratsText->getLocalBounds();
                    //Center text
                    congratsText->setOrigin(textBounds.width / 2.f, 0);
                    congratsText->setPosition(512, 10);
                }

                //Disable the next and previous buttons, because we do not need them for 1 or 0 solutions.
                nextSolutionButton->setListenerEnabled(false);
                nextSolutionButton->setToDraw(false);
                previousSolutionButton->setListenerEnabled(false);
                previousSolutionButton->setToDraw(false);
            }
        });
    mouseListeners.push_back(stageButtons[5].back());
    

    //Initialize all stages to be disabled except the menu
    for (int i = 1; i < 6; i++) {
        for (shared_ptr<Button> button : stageButtons[i]) {
            button->setToDraw(false);
            button->setListenerEnabled(false);
        }
    }

    cout << "\nComplete!\n";
    //END LOADING

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            switch (event.type) 
            {
            case(sf::Event::Closed):
                if(programStage == 2)
                    master.saveProgress(difficulty);
                window.close();
                break;
            case(sf::Event::MouseMoved):
                for (shared_ptr<MouseListener> listener : mouseListeners) {
                    if (listener->getListenerEnabled())
                        listener->mouseMoved(event);
                }
                break;
            case(sf::Event::MouseButtonPressed):
                for (shared_ptr<MouseListener> listener : mouseListeners) {
                    if (listener->getListenerEnabled())
                        listener->mouseClick(event);
                }
                break;
            default:
                break;
            }
        }

        window.clear();

        //If we are in between stages, don't display the stage texts
        if (!inbetweenStages) {
            for (shared_ptr<sf::Text> text : stageTexts[programStage]) {
                window.draw(*text);
            }
        }

        //Display all the buttons in this stage
        for (shared_ptr<Button> button : stageButtons[programStage]) {
            if (button->getToDraw()) {
                //Lock the mutex so that the sudoku thread doesn't try to write data while we are reading data
                master.mtx.lock();
                window.draw(*button);
                //Unlock the mutex to free the sudoku thread
                master.mtx.unlock();
            }
        }

        //Draw the separators for the sudoku board
        if (programStage >=2 && programStage <= 5) {
            for (int i = 0; i < 4; i++) {
                window.draw(master.separatorRects[i]);
            }
        }

        if (generatingPuzzle) {
            window.draw(generatingText);
        }

        if (loadPuzzleFailed) {
            window.draw(loadFailText);
        }

        window.display();
    }

    return 0;
}

//Deactivate buttons from current stage
void leaveStage(short oldStage, vector<shared_ptr<Button>> stageButtons[]) {
    for (shared_ptr<Button> buttonPtr : stageButtons[oldStage]) {
        buttonPtr->setToDraw(false);
        buttonPtr->setListenerEnabled(false);
    }
}

//Activate buttons for next stage
void enterStage(short newStage, vector<shared_ptr<Button>> stageButtons[]) {
    for (shared_ptr<Button> buttonPtr : stageButtons[newStage]) {
        buttonPtr->setToDraw(true);
        buttonPtr->setListenerEnabled(true);
        buttonPtr->setup();
    }
}

//Activate and deactivate buttons
void changeStage(short newStage, short oldStage, vector<shared_ptr<Button>> stageButtons[])
{
    leaveStage(oldStage, stageButtons);
    enterStage(newStage, stageButtons);
}
